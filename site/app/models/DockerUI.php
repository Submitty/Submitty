<?php

namespace app\models;

use app\libraries\Core;
use app\libraries\FileUtils;
use app\libraries\Logger;
use app\exceptions\DockerLogParseException;
use app\data_objects\WorkerMachine;
use app\data_objects\WorkerMachineSystemInformation;
use app\data_objects\DockerImage;

/**
 * Represents the data parsed from the docker autograding and worker json files
 *
 * @method array getCapabilities()
 * @method string getNoImageCapabilities()
 * @method array getWorkerMachines()
 * @method array getCapabilityToColorMapping()
 * @method string getLastRan()
 * @method string getSysinfoLastUpdated()
 * @method array getErrorLogs()
 * @method array getDockerImages()
 * @method array getFailImages()
 */
class DockerUI extends AbstractModel {
    /** @var array<mixed> Json data passed in from controller */
    private array $json_data;
    /** @var array<WorkerMachine> List of worker machine names */
    protected array $worker_machines;
    /** @var array<string> List of capability tags */
    protected array $capabilities;
    /** @var array<string> List of capabilities unassociated with any container */
    protected array $no_image_capabilities;
    /** @var array<string,string> Mapping between capabilities and the color to draw their badge */
    protected array $capability_to_color_mapping;
    /** Human readable string of when the docker logs generated by Submitty were last parsed */
    protected string $last_ran = "Unknown";
    /** Human readable string of when the sysinfo logs were last parsed */
    protected string $sysinfo_last_updated = "Unknown";
    /** @var array<string> List of errors from parsing log files  */
    protected array $error_logs = [];
    /** location of where the sysinfo log files generated by Submitty are located */
    private string $sysinfo_filepath;
    /** location of where logs generated by Submitty related to docker are located */
    private string $docker_logpath;
    /** @var array<DockerImage> A list of \DockerImages */
    protected array $docker_images = [];
    /** @var array<string> A list of docker image names that could not be pulled */
    protected array $fail_images = [];
    /** @var array<mixed> Mapping between images to which Submitty capabilities they are associated with */
    private array $image_to_capability_mapping;
    /**
     * Mapping between workers and the docker version they run, this is collected from the
     * docker logs but displayed later in the worker machines table
     * @var array<string, string>
     */
    private array $worker_docker_versions = [];
    /**
     * Mapping between workers and the os they have, this is collected from the
     * docker logs but displayed later in the worker machines table
     * @var array<string, string>
     */
    private array $worker_os_names = [];


    /**
     * Create a new docker UI object from the json data read from the filesystem
     * @param array<mixed> $json
     */
    public function __construct(Core $core, array $json) {
        parent::__construct($core);


        /** Sanity checks on given json structure */
        assert(array_key_exists('autograding_workers', $json) && is_array($json['autograding_workers']));
        assert(array_key_exists('autograding_containers', $json) && is_array($json['autograding_containers']));
        assert(array_key_exists('image_owners', $json) && is_array($json['image_owners']));

        $this->sysinfo_filepath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "sysinfo");
        $this->docker_logpath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "docker");

        $this->json_data = $json;

        try {
            $this->parseWorkersAndCapabilities($this->json_data['autograding_containers'], $this->json_data['autograding_workers']);
            $this->parseDockerLogs();
            $this->parseSystemInformationLogs();
        }
        catch (DockerLogParseException $e) {
            $this->error_logs[] = $e->getMessage();
            Logger::error($e->getMessage());
        }

        if (count($this->fail_images) > 0) {
            Logger::error("Failed to pull images: '" . implode($this->fail_images) . "'");
        }
    }

    /**
     * Return a list of autograding worker names
     * @return array<mixed>
     */
    public function getAutogradingContainers(): array {
        return $this->json_data['autograding_containers'];
    }

    /**
     * Return a mapping of docker image IDs to their owner's user_ids
     * @return array<string,string>
     */
    public function getDockerImageOwners(): array {
        return $this->json_data['image_owners'];
    }

    /**
     * Collect which capabilities are present along with the workers associated with and any that are unaassociated
     * @param array<mixed> $autograding_containers - parsed JSON with autograding container information
     * @param array<mixed> $autograding_workers - parsed JSON with autograding worker information
     */
    private function parseWorkersAndCapabilities(array $autograding_containers, array $autograding_workers): void {
        $capabilities = [];
        $no_image_capabilities = [];
        $image_to_capability = [];

        foreach ($autograding_workers as $name => $worker) {
            //worker with some defaults
            $worker_temp = new WorkerMachine(
                $name,
                $worker['num_autograding_workers'] ?? 0,
                $worker['capabilities'] ?? [],
                $worker['enabled'] ?? false,
            );

            foreach ($worker_temp->capabilities as $capability) {
                $capabilities[] = $capability;

                if (isset($autograding_containers[$capability])) {
                    foreach ($autograding_containers[$capability] as $image) {
                        $image_to_capability[$image][] = $capability;
                    }
                }
                else {
                    $no_image_capabilities[] = $capability;
                }
            }

            $this->worker_machines[] = $worker_temp;
        }

        sort($capabilities);
        $this->capabilities = array_unique($capabilities);
        //deduplicate capability lists
        $this->no_image_capabilities = array_unique($no_image_capabilities);
        foreach ($image_to_capability as $image => $map) {
            $image_to_capability[$image] = array_unique($map);
        }

        $this->image_to_capability_mapping = $image_to_capability;
        $this->capability_to_color_mapping = [];
        foreach ($this->capabilities as $index => $capability) {
            $this->capability_to_color_mapping[$capability] = min($index + 1, 20);
        }
    }

    /**
     * Entry point to parse logs generated by Submitty containing information on docker images across workers
     * @throws DockerLogParseException
     */
    private function parseDockerLogs(): void {
        $array_list = scandir($this->docker_logpath);
        if ($array_list === false) {
            throw new DockerLogParseException("Failed to scandir at path '" . $this->docker_logpath . "'");
        }

        //ignore the '.' and '..' directories, if there are no files to parse, nothing to do, exit
        if (count($array_list) <= 2) {
            return;
        }

        $most_recent = max($array_list);
        $content = file_get_contents(FileUtils::joinPaths($this->docker_logpath, $most_recent));
        if ($content === false || strlen($content) <= 35) {
            //the docker log file is probably being written or is in the process of being written, exit now
            //and the next time the user loads the page it will be attempted to be read again
            return;
        }

        //each subsequent update on the same day will append to the same docker log, navigate to the last update block and parse that
        $content = rtrim($content);
        $contentStart = strrpos($content, "[Last ran", -35);
        $contentStart = $contentStart === false ? 0 : $contentStart;
        $content = substr($content, $contentStart + 10);

        $buffer = strtok($content, "\n");
        $current_machine = null;

        while ($buffer !== false) {
            $current_machine = $this->parseLogLine($buffer, $current_machine);
            if (preg_last_error() !== PREG_NO_ERROR) {
                $this->error_logs[] = "Error while parsing the logs";
                break;
            }
            $buffer = strtok("\n");
        }
    }

    /**
     * Helper function to parse docker logs, returns an updated current_machine if applicable
     * If parsing the description or docker version, the current_machine is expected to be known at that point
     **/
    private function parseLogLine(string $line, ?string $current_machine): ?string {
        $matches = [];
        // Match patterns, preg_match returns 1 on match
        if (preg_match("/^\[Last ran on: ([0-9 :-]{19})\]/", $line, $matches) === 1) {
            $this->last_ran = $matches[1];
        }
        elseif (preg_match("/FAILURE TO UPDATE MACHINE (.+)$/", $line, $matches) === 1) {
            $this->setWorkerToFailure($matches[1]);
            $this->error_logs[] = $line;
        }
        elseif (preg_match("/ERROR: Could not pull (.+)/", $line, $matches) === 1) {
            $this->fail_images[] = $matches[1];
            $this->error_logs[] = $line;
        }
        elseif (preg_match("/UPDATE MACHINE: (.+)/", $line, $matches) === 1) {
            $current_machine = $matches[1];
        }
        elseif (preg_match("/Description:\t(.+)/", $line, $matches) === 1 && $current_machine !== null) {
            $this->worker_os_names[$current_machine] = $matches[1];
        }
        elseif (preg_match("/Docker Version: (.+)/", $line, $matches) === 1 && $current_machine !== null) {
            $this->worker_docker_versions[$current_machine] = $matches[1];
        }
        elseif (preg_match("/Tag: (.+)/", $line, $matches) === 1) {
            $this->parseImageDetails($matches[1]);
        }
        elseif (preg_match("/APIError was raised./", $line) === 1) {
            $this->error_logs[] = "APIError has occurred, please update the machines.";
        }

        return $current_machine;
    }

    /** Search for a worker by name and set its status to 'failed to update' */
    private function setWorkerToFailure(string $target_name): void {
        foreach ($this->worker_machines as &$worker) {
            if ($worker->name === $target_name) {
                $worker->failed_to_update = true;
                break;
            }
        }
    }

    /** helper function to parse image information */
    private function parseImageDetails(string $tags): void {
        $image_array = explode(", ", $tags);
        // Read next three lines for additional details
        $image = $this->readImageDetails();

        //take the first name in the list of name:tags and use that as the primary
        $image->primary_name = array_shift($image_array);
        $image->aliases = $image_array;
        if (array_key_exists($image->primary_name, $this->image_to_capability_mapping)) {
            $image->capabilities = $this->image_to_capability_mapping[$image->primary_name];
        }

        $this->docker_images[] = $image;
    }

    /** Collect the details of an image and return them in a map, in the future a class should represent the return */
    private function readImageDetails(): DockerImage {
        $log_lines = [];

        for ($i = 0; $i < 3; $i++) {
            $line = strtok("\n");
            if ($line === false) {
                throw new DockerLogParseException("Unexpected end of log while reading image details.");
            }

            $log_lines[] = $line;
        }

        return DockerImage::fromLog($log_lines);
    }

    /** Parse the logs under the sysinfo dir for worker machine info */
    private function parseSystemInformationLogs(): void {
        $sysinfo_files = scandir($this->sysinfo_filepath);
        if ($sysinfo_files === false) {
            throw new DockerLogParseException("Failed to scandir at path '" . $this->sysinfo_filepath . "'");
        }

        //ignore the '.' and '..' directories, if there are no files to parse, nothing to do, exit
        if (count($sysinfo_files) <= 2) {
            return;
        }

        $sysinfo_most_recent = max($sysinfo_files);
        $sysinfo_content = file_get_contents(FileUtils::joinPaths($this->sysinfo_filepath, $sysinfo_most_recent));

        if ($sysinfo_content === false || strlen($sysinfo_content) <= 45) {
            //the system info log file is probably being written or is in the process of being written, exit now
            //and the next time the user loads the page it will be attempted to be read again
            return;
        }

        //each subsequent update on the same day will append to the same docker log, navigate to the last update block and parse that
        $sysinfo_content = rtrim($sysinfo_content);
        $contentStart = strrpos($sysinfo_content, "[Last ran", -45);
        $contentStart = $contentStart === false ? 0 : $contentStart;
        $sysinfo_content = substr($sysinfo_content, $contentStart + 10);
        $buffer = strtok($sysinfo_content, "\n");
        //the first line is expected to be "---", consume that to get to the start of the block
        $buffer = strtok("\n");
        $current_machine = null;

        $machine_system_details = [];
        while ($buffer !== false) {
            $matches = [];

            $is_match = preg_match("/System Info :: (.+)/", $buffer, $matches);
            if (preg_match("/System Info :: (.+)/", $buffer, $matches) === 1) {
                $current_machine = $matches[1];
            }

            if ($current_machine === null) {
                //if have not set the current_machine at this point, keep consuming lines until we see it
                $buffer = strtok("\n");
                continue;
            }

            $is_match = preg_match("/Worker Service: (.+)/", $buffer, $matches);
            if ($is_match === 1 && $matches[1] !== "Service Not Found") {
                $machine_system_details[$current_machine]["worker"] = $matches[1];
            }

            $is_match = preg_match("/Shipper Service: (.+)/", $buffer, $matches);
            if ($is_match === 1 && $matches[1] !== "Service Not Found") {
                $machine_system_details[$current_machine]["shipper"] = $matches[1];
            }

            $is_match = preg_match("/Daemon Job Handler: (.+)/", $buffer, $matches);
            if ($is_match === 1 && $matches[1] !== "Service Not Found") {
                $machine_system_details[$current_machine]["daemon"] = $matches[1];
            }

            $is_match = preg_match("/Disk Usage: (.+)/", $buffer, $matches);
            if ($is_match === 1) {
                $machine_system_details[$current_machine]["disk"] = $matches[1];
            }

            $is_match = preg_match("/System Load: \((.+)\)/", $buffer, $matches);
            if ($is_match === 1) {
                $machine_system_details[$current_machine]["load"] = $matches[1];
            }

            if (preg_match("/^\[Last ran on: (.+)\]/", $buffer, $matches) === 1) {
                $this->sysinfo_last_updated = $matches[1];
            }

            if (preg_match("/ERR:/", $buffer, $matches) === 1) {
                $this->error_logs[] = "Failed to update system info";
            }

            if (preg_last_error() !== PREG_NO_ERROR) {
                $this->error_logs[] = "Error while parsing system info logs";
                break;
            }

            $buffer = strtok("\n");
        }

        foreach ($machine_system_details as $key => $value) {
            $worker_info = WorkerMachineSystemInformation::fromArray($value, $key);
            //now find the worker and append the information parsed to it
            foreach ($this->worker_machines as &$worker) {
                if ($worker->name === $key) {
                    $worker->system_information = $worker_info;
                    $worker->docker_version = $this->worker_docker_versions[$key] ?? "Unknown";
                    $worker->os = $this->worker_os_names[$key] ?? "Unknown";
                    break;
                }
            }
        }
    }
}
