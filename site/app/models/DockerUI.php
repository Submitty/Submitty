<?php

namespace app\models;

use app\libraries\Core;
use app\libraries\FileUtils;

/**
 * Represents the data parsed from the docker autograding and worker json files
 * 
 * @method string getWorkerMachineNames()
 * @method string getCapabilities()
 * @method string getNoImageCapabilities()
 * @method string getWorkerMachineNames()
 * @method string getImageToCapabilityMapping()
 * @method string getCapabilityToColorMapping()
 */
class DockerUI extends AbstractModel {
    /** Json data passed in */
    private array $json_data;
    /** List of worker machine names */
    protected array $worker_machine_names;
    /** List of capability tags */
    protected array $capabilities;
    /** List of capabilities unassociated with any container */
    protected array $no_image_capabilities;
    /** Mapping between images to capabilities */
    protected array $image_to_capability_mapping;
    /** Mapping between capabilities and the color to draw their badge */
    protected array $capability_to_color_mapping;
    /** location of where the sysinfo log files generated by Submitty are located */
    private string $sysinfo_filepath;
    /** location of where logs generated by Submitty related to docker are located */
    private string $docker_logpath;
    /** Create a new docker UI object from the json data read from the filesystem */
    public function __construct(Core $core, array $json) {
        parent::__construct($core);

        /** Sanity checks on given json structure */
        assert(array_key_exists('autograding_workers', $json) && is_array($json['autograding_workers']));
        assert(array_key_exists('autograding_containers', $json) && is_array($json['autograding_containers']));

        $this->sysinfo_filepath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "sysinfo");
        $this->docker_logpath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "docker");

        $this->json_data = $json;
        $this->parseWorkersAndCapabilities();
    }

    /** Return a list of autograding worker names */
    public function getAutogradingContainers(): array {
        return $this->json_data['autograding_containers'];
    }

    /** Collect which capabilities are present along with the workers associated with and any that are unaassociated */
    private function parseWorkersAndCapabilities(): void {
        $capabilities = [];
        $no_image_capabilities = [];
        $image_to_capability = [];
        $autograding_containers = $this->json_data['autograding_containers'];
        
        foreach ($this->json_data['autograding_workers'] as $name => $worker) {
            //worker with some defaults
            $worker_temp = [
                'name' => $name,
                'num_autograding_workers' => $worker['num_autograding_workers'] ?? 0,
                'enabled' => $worker['enabled'] ?? false,
                'capabilities' => $worker['capabilities'] ?? [],
                'images_not_found' => [],
            ];

            foreach ($worker_temp['capabilities'] as $capability) {
                $capabilities[] = $capability;
    
                if (isset($autograding_containers[$capability])) {
                    foreach ($autograding_containers[$capability] as $image) {
                        $image_to_capability[$image][] = $capability;
                    }
                } else {
                    $no_image_capabilities[] = $capability;
                    $workerTemp['images_not_found'][] = $capability;
                }
            }

            $this->worker_machine_names[] = $worker_temp;
        }

        sort($capabilities);
        $this->capabilities = array_unique($capabilities);
        //deduplicate capability lists
        $this->no_image_capabilities = array_unique($no_image_capabilities);
        $this->image_to_capability_mapping = array_map('array_unique', $image_to_capability);

        foreach ($image_to_capability as $image => $map) {
            $image_to_capability[$image] = array_unique($map);
        }

        $this->image_to_capability_mapping = $image_to_capability;
        $this->capability_to_color_mapping = [];
        foreach ($this->capabilities as $index => $capability) {
            $this->capability_to_color_mapping[$capability] = min($index + 1, 20);
        }
    }

}