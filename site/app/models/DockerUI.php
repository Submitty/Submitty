<?php

namespace app\models;

use app\libraries\Core;
use app\libraries\FileUtils;

/**
 * Represents the data parsed from the docker autograding and worker json files
 * 
 * @method string getWorkerMachineNames()
 * @method string getCapabilities()
 * @method string getNoImageCapabilities()
 * @method string getWorkerMachineNames()
 * @method string getImageToCapabilityMapping()
 * @method string getCapabilityToColorMapping()
 */
class DockerUI extends AbstractModel {
    /** Json data passed in */
    private array $json_data;
    /** List of worker machine names */
    protected array $worker_machine_names;
    /** List of capability tags */
    protected array $capabilities;
    /** List of capabilities unassociated with any container */
    protected array $no_image_capabilities;
    /** Mapping between images to capabilities */
    protected array $image_to_capability_mapping;
    /** Mapping between capabilities and the color to draw their badge */
    protected array $capability_to_color_mapping;
    /** location of where the sysinfo log files generated by Submitty are located */
    private string $sysinfo_filepath;
    /** location of where logs generated by Submitty related to docker are located */
    private string $docker_logpath;
    /** Create a new docker UI object from the json data read from the filesystem */
    public function __construct(Core $core, array $json) {
        parent::__construct($core);

        /** Sanity checks on given json structure */
        assert(array_key_exists('autograding_workers', $json) && is_array($json['autograding_workers']));
        assert(array_key_exists('autograding_containers', $json) && is_array($json['autograding_containers']));

        $this->sysinfo_filepath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "sysinfo");
        $this->docker_logpath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "docker");

        $this->json_data = $json;
        $this->parseWorkersAndCapabilities();
        $this->parseDockerLogs();
    }

    /** Return a list of autograding worker names */
    public function getAutogradingContainers(): array {
        return $this->json_data['autograding_containers'];
    }

    /** Collect which capabilities are present along with the workers associated with and any that are unaassociated */
    private function parseWorkersAndCapabilities(): void {
        $capabilities = [];
        $no_image_capabilities = [];
        $image_to_capability = [];
        $autograding_containers = $this->json_data['autograding_containers'];
        
        foreach ($this->json_data['autograding_workers'] as $name => $worker) {
            //worker with some defaults
            $worker_temp = [
                'name' => $name,
                'num_autograding_workers' => $worker['num_autograding_workers'] ?? 0,
                'enabled' => $worker['enabled'] ?? false,
                'capabilities' => $worker['capabilities'] ?? [],
                'images_not_found' => [],
            ];

            foreach ($worker_temp['capabilities'] as $capability) {
                $capabilities[] = $capability;
    
                if (isset($autograding_containers[$capability])) {
                    foreach ($autograding_containers[$capability] as $image) {
                        $image_to_capability[$image][] = $capability;
                    }
                } else {
                    $no_image_capabilities[] = $capability;
                    $workerTemp['images_not_found'][] = $capability;
                }
            }

            $this->worker_machine_names[] = $worker_temp;
        }

        sort($capabilities);
        $this->capabilities = array_unique($capabilities);
        //deduplicate capability lists
        $this->no_image_capabilities = array_unique($no_image_capabilities);
        $this->image_to_capability_mapping = array_map('array_unique', $image_to_capability);

        foreach ($image_to_capability as $image => $map) {
            $image_to_capability[$image] = array_unique($map);
        }

        $this->image_to_capability_mapping = $image_to_capability;
        $this->capability_to_color_mapping = [];
        foreach ($this->capabilities as $index => $capability) {
            $this->capability_to_color_mapping[$capability] = min($index + 1, 20);
        }
    }


    private function parseDockerLogs(): void {
        if (count($array_list) > 2) {
            $most_recent = max($array_list);
            $content = file_get_contents(
                FileUtils::joinPaths(
                    $this->core->getConfig()->getSubmittyPath(),
                    "logs/docker",
                    $most_recent
                )
            );

            if ($content) {
                $content = rtrim($content);
                $content_2rpos = strrpos($content, "[Last ran", -35);
                if ($content_2rpos === false) {
                    $content_2rpos = 0;
                }
                $content = substr($content, $content_2rpos + 10);
                $buffer = strtok($content, "\n");
                $current_machine = "";
                while ($buffer !== false) {
                    $matches = [];

                    $is_match = preg_match("/^\[Last ran on: ([0-9 :-]{19})\]/", $buffer, $matches);
                    if ($is_match === 1) {
                        $last_ran = $matches[1];
                    }

                    $is_match = preg_match("/FAILURE TO UPDATE MACHINE (.+)$/", $buffer, $matches);
                    if ($is_match) {
                        $machine_to_update[$matches[1]] = false;
                        $error_logs[] = $buffer;
                    }

                    $is_match = preg_match("/ERROR: Could not pull (.+)/", $buffer, $matches);
                    if ($is_match) {
                        $fail_images = $matches[1];
                        $error_logs[] = $buffer;
                    }
                    // Note the machine currently described by the log
                    $is_match = preg_match("/UPDATE MACHINE: (.+)/", $buffer, $matches);
                    if ($is_match) {
                        $current_machine = $matches[1];
                    }

                    // Parse the OS description
                    $is_match = preg_match("/Description:\t(.+)/", $buffer, $matches);
                    if ($is_match) {
                        $machine_system_details[$current_machine]["os"] = $matches[1] ?? null;
                    }

                    // Parse the docker version
                    $is_match = preg_match("/Docker Version: (.+)/", $buffer, $matches);
                    if ($is_match) {
                        $machine_docker_version[$current_machine] = $matches[1];
                    }

                    // Check if the log entry is describing a machine
                    $is_match = preg_match("/Tag: (.+)/", $buffer, $matches);
                    if ($is_match) {
                        $image_arr = explode(", ", $matches[1]);
                        $current_image = $image_arr[0];
                        array_shift($image_arr);
                        // reset this for newer entries of the log
                        $aliases[$current_image] = [$current_image];
                        foreach ($image_arr as $image) {
                            $aliases[$image][] = $current_image;
                        }
                        // Read the next 3 lines for more info
                        // read id
                        $buffer = strtok("\n");
                        $is_match = preg_match("/\t-id: (.+)/", $buffer, $matches);
                        if (!$buffer || !$is_match) {
                            throw new ParseError("Unexpected log input, attempted to read image id");
                        }
                        $id = $matches[1];

                        // read created
                        $buffer = strtok("\n");
                        $is_match = preg_match("/\t-created: (.+)/", $buffer, $matches);
                        if (!$buffer || !$is_match) {
                            throw new ParseError("Unexpected log input, attempted to read image creation date");
                        }
                        $created = $matches[1];

                        // read size
                        $buffer = strtok("\n");
                        $is_match = preg_match("/\t-size: (.+)/", $buffer, $matches);
                        if (!$buffer || !$is_match) {
                            throw new ParseError("Unexpected log input, attempted to read image size");
                        }
                        $size = $matches[1];

                        foreach ($aliases[$current_image] as $alias) {
                            $image_info[$alias] = [
                                "id" => $id,
                                "created" => \DateTime::createFromFormat('Y-m-d\TH:i:s+', $created)->format("Y-m-d H:i:s"),
                                "size" => Utils::formatBytes('mb', $size, true)
                            ];
                        }
                    }

                    $is_match = preg_match("/APIError was raised./", $buffer, $matches);
                    if ($is_match) {
                        $error_logs[] = "APIError has occurred, please update the machines.";
                    }
                    if (preg_last_error() != PREG_NO_ERROR) {
                        $error_logs[] = "Error while parsing the logs";
                        break;
                    }
                    $buffer = strtok("\n");
                }
            }
        }
    }

    private function parseSystemInformationLogs(): void {
        if (count($sysinfo_files) > 2) {
            $sysinfo_most_recent = max($sysinfo_files);
            $sysinfo_content = file_get_contents(
                FileUtils::joinPaths(
                    $this->core->getConfig()->getSubmittyPath(),
                    "logs/sysinfo",
                    $sysinfo_most_recent
                )
            );

            if ($sysinfo_content) {
                $sysinfo_content = rtrim($sysinfo_content);
                $sysinfo_2rpos = strrpos($sysinfo_content, "[Last ran", -45);
                if ($sysinfo_2rpos === false) {
                    $sysinfo_2rpos = 0;
                }
                $sysinfo_content = substr($sysinfo_content, $sysinfo_2rpos + 10);
                $buffer = strtok($sysinfo_content, "\n");
                $current_machine = "";

                while ($buffer !== false) {
                    $matches = [];

                    $is_match = preg_match("/System Info :: (.+)/", $buffer, $matches);
                    if ($is_match) {
                        $current_machine = $matches[1];
                        $machine_system_details[$current_machine]["worker"] = null;
                        $machine_system_details[$current_machine]["shipper"] = null;
                        $machine_system_details[$current_machine]["daemon"] = null;
                        $machine_system_details[$current_machine]["disk"] = null;
                        $machine_system_details[$current_machine]["load"] = null;
                        $machine_system_details[$current_machine]["os"] ??= null;
                    }

                    $is_match = preg_match("/Worker Service: (.+)/", $buffer, $matches);
                    if ($is_match && $matches[1] != "Service Not Found") {
                        $machine_system_details[$current_machine]["worker"] = $matches[1];
                    }

                    $is_match = preg_match("/Shipper Service: (.+)/", $buffer, $matches);
                    if ($is_match && $matches[1] != "Service Not Found") {
                        $machine_system_details[$current_machine]["shipper"] = $matches[1];
                    }

                    $is_match = preg_match("/Daemon Job Handler: (.+)/", $buffer, $matches);
                    if ($is_match && $matches[1] != "Service Not Found") {
                        $machine_system_details[$current_machine]["daemon"] = $matches[1];
                    }

                    $is_match = preg_match("/Disk Usage: (.+)/", $buffer, $matches);
                    if ($is_match) {
                        $machine_system_details[$current_machine]["disk"] = $matches[1];
                    }

                    $is_match = preg_match("/System Load: \((.+)\)/", $buffer, $matches);
                    if ($is_match) {
                        $machine_system_details[$current_machine]["load"] = $matches[1];
                    }

                    $is_match = preg_match("/^\[Last ran on: (.+)\]/", $buffer, $matches);
                    if ($is_match) {
                        $sysinfo_last_updated = $matches[1];
                    }

                    $is_match = preg_match("/ERR:/", $buffer, $matches);
                    if ($is_match) {
                        $error_logs[] = "Failed to update system info";
                    }

                    if (preg_last_error() != PREG_NO_ERROR) {
                        $error_logs[] = "Error while parsing system info logs";
                        break;
                    }

                    $buffer = strtok("\n");
                }
            }
        }
    }

}