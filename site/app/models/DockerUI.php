<?php

namespace app\models;

use app\libraries\Core;
use app\libraries\DateUtils;
use app\libraries\Utils;
use app\libraries\FileUtils;
use app\libraries\Logger;
use app\exceptions\DockerLogParseException;
use app\data_objects\WorkerMachine;
use app\data_objects\WorkerMachineSystemInformation;

/** 
 * Simple class to represent docker image from parsed information
 */
class DockerImage {
    /** The Docker image ID */
    public string $id;
    /** Date of creation, reported by Docker */
    public \DateTime $created;
    /** Human readable timestamp from the date of creation */
    public string $created_timestamp;
    /** size of the image in human readable format */
    public string $size_mb;
    /** The name:tag of the image */
    public string $primary_name;
    /** Any other name:tags that also point to this image */
    public array $aliases = [];
    /** What Submitty capabilities this image is associated with */
    public array $capabilities = [];
    /** Create a new DockerImage object*/
    public function __construct(string $id, \DateTime $created, string $size) {
        $this->id = $id;
        $this->created = $created;
        $this->created_timestamp = DateUtils::dateTimeToString($created);
        $this->size_mb = $size;
    }

    /** 
     * Construct a new DockerImage from log lines
     * @throws DockerLogParseException
     */
    public static function fromLog(array $logLines): self {
        if (count($logLines) < 3) {
            throw new DockerLogParseException("Unexpected log input, insufficient lines for image details.");
        }

        // Parse ID
        if (!preg_match("/\t-id: (.+)/", $logLines[0], $matches)) {
            throw new DockerLogParseException("Unexpected log input, attempted to read image ID.");
        }

        $id = $matches[1];
        // Parse created date
        if (!preg_match("/\t-created: (.+)/", $logLines[1], $matches)) {
            throw new DockerLogParseException("Unexpected log input, attempted to read image creation date.");
        }

        $created = \DateTime::createFromFormat('Y-m-d\TH:i:s+', $matches[1]);
        if (!$created) {
            throw new DockerLogParseException("Invalid date format in log input.");
        }

        // Parse size
        if (!preg_match("/\t-size: (.+)/", $logLines[2], $matches)) {
            throw new DockerLogParseException("Unexpected log input, attempted to read image size.");
        }

        $size = Utils::formatBytes('mb', $matches[1], true);
        return new self($id, $created, $size);
    }
}

/**
 * Represents the data parsed from the docker autograding and worker json files
 * 
 * @method string getCapabilities()
 * @method string getNoImageCapabilities()
 * @method array getWorkerMachines()
 * @method array getCapabilityToColorMapping()
 * @method string getLastRan()
 * @method string getSysinfoLastUpdated()
 * @method array getErrorLogs()
 * @method array getDockerImages()
 */
class DockerUI extends AbstractModel {
    /** Json data passed in */
    private array $json_data;
    /** List of worker machine names */
    protected array $worker_machines;
    /** List of capability tags */
    protected array $capabilities;
    /** List of capabilities unassociated with any container */
    protected array $no_image_capabilities;
    /** Mapping between capabilities and the color to draw their badge */
    protected array $capability_to_color_mapping;
    /** Human readable string of when the docker logs generated by Submitty were last parsed */
    protected string $last_ran = "Unknown";
    /** Human readable string of when the sysinfo logs were last parsed */
    protected string $sysinfo_last_updated = "Unknown";
    /** List of errors from parsing log files  */
    protected array $error_logs = [];
    /** location of where the sysinfo log files generated by Submitty are located */
    private string $sysinfo_filepath;
    /** location of where logs generated by Submitty related to docker are located */
    private string $docker_logpath;
    /** A list of \DockerImages */
    protected array $docker_images = [];
    private array $fail_images;
    /** Mapping between images to which Submitty capabilities they are associated with */
    private array $image_to_capability_mapping;
    /** 
     * Mapping between workers and the docker version they run, this is collected from the 
     * docker logs but displayed later in the worker machines table
     */
    private array $worker_docker_versions = [];
    /** 
     * Mapping between workers and the os they have, this is collected from the 
     * docker logs but displayed later in the worker machines table
     */
    private array $worker_os_names = [];


    /** Create a new docker UI object from the json data read from the filesystem */
    public function __construct(Core $core, array $json) {
        parent::__construct($core);

        /** Sanity checks on given json structure */
        assert(array_key_exists('autograding_workers', $json) && is_array($json['autograding_workers']));
        assert(array_key_exists('autograding_containers', $json) && is_array($json['autograding_containers']));

        $this->sysinfo_filepath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "sysinfo");
        $this->docker_logpath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "docker");

        $this->json_data = $json;

        try {
            $this->parseWorkersAndCapabilities($this->json_data['autograding_containers'], $this->json_data['autograding_workers']);
            $this->parseDockerLogs();
            $this->parseSystemInformationLogs();
        } catch (Exception $e) {
            $this->error_logs[] = $e->getMessage();
            Logger::error($e->getMessage());
        }
    }

    /** Return a list of autograding worker names */
    public function getAutogradingContainers(): array {
        return $this->json_data['autograding_containers'];
    }

    /** Collect which capabilities are present along with the workers associated with and any that are unaassociated */
    private function parseWorkersAndCapabilities(array $autograding_containers, array $autograding_workers): void {
        $capabilities = [];
        $no_image_capabilities = [];
        $image_to_capability = [];
        
        foreach ($autograding_workers as $name => $worker) {
            //worker with some defaults
            $worker_temp = new WorkerMachine(
                $name,
                $worker['num_autograding_workers'] ?? 0,
                $worker['capabilities'] ?? [],
                $worker['enabled'] ?? false,
            );

            foreach ($worker_temp->capabilities as $capability) {
                $capabilities[] = $capability;
    
                if (isset($autograding_containers[$capability])) {
                    foreach ($autograding_containers[$capability] as $image) {
                        $image_to_capability[$image][] = $capability;
                    }
                } else {
                    $no_image_capabilities[] = $capability;
                }
            }

            $this->worker_machines[] = $worker_temp;
        }

        sort($capabilities);
        $this->capabilities = array_unique($capabilities);
        //deduplicate capability lists
        $this->no_image_capabilities = array_unique($no_image_capabilities);
        foreach ($image_to_capability as $image => $map) {
            $image_to_capability[$image] = array_unique($map);
        }

        $this->image_to_capability_mapping = $image_to_capability;
        $this->capability_to_color_mapping = [];
        foreach ($this->capabilities as $index => $capability) {
            $this->capability_to_color_mapping[$capability] = min($index + 1, 20);
        }
    }

    /** 
     * Entry point to parse logs generated by Submitty containing information on docker images across workers
     * @throws DockerLogParseException
     */
    private function parseDockerLogs(): void {
        $array_list = scandir($this->docker_logpath);
        if($array_list === false) {
           throw new DockerLogParseException("Failed to scandir at path '" . $this->docker_logpath . "'" ); 
        }

        //ignore the '.' and '..' directories, if there are no files to parse, nothing to do, exit
        if(count($array_list) <= 2) {
            return;
        }

        $most_recent = max($array_list);
        $content = file_get_contents(FileUtils::joinPaths($this->docker_logpath, $most_recent));
        if($content === false || strlen($content) <= 35) {
            //the docker log file is probably being written or is in the process of being written, exit now 
            //and the next time the user loads the page it will be attempted to be read again
            return; 
        }

        //each subsequent update on the same day will append to the same docker log, navigate to the last update block and parse that
        $content = rtrim($content);
        $contentStart = strrpos($content, "[Last ran", -35);
        $contentStart = $contentStart === false ? 0 : $contentStart;
        $content = substr($content, $contentStart + 10);

        $buffer = strtok($content, "\n");
        $current_machine = null;

        while ($buffer !== false) {
            $current_machine = $this->parseLogLine($buffer, $current_machine);
            if (preg_last_error() != PREG_NO_ERROR) {
                $error_logs[] = "Error while parsing the logs";
                break;
            }
            $buffer = strtok("\n");
        }
        
    }

    /** 
     * Helper function to parse docker logs, returns an updated current_machine if applicable 
     * If parsing the description or docker version, the current_machine is expected to be known at that point
     **/
    private function parseLogLine(string $line, ?string $current_machine): ?string {
        $matches = [];
        // Match patterns, preg_match returns 1 on match
        if (preg_match("/^\[Last ran on: ([0-9 :-]{19})\]/", $line, $matches) === 1) {            
            $this->last_ran = $matches[1];
        } elseif (preg_match("/FAILURE TO UPDATE MACHINE (.+)$/", $line, $matches) === 1) {
            $this->setWorkerToFailure($matches[1]);
            $this->error_logs[] = $line;
        } elseif (preg_match("/ERROR: Could not pull (.+)/", $line, $matches) === 1) {
            $this->fail_images[] = $matches[1];
            $this->error_logs[] = $line;
        } elseif (preg_match("/UPDATE MACHINE: (.+)/", $line, $matches) === 1) {
            $current_machine = $matches[1];
        } elseif (preg_match("/Description:\t(.+)/", $line, $matches) === 1 && $current_machine !== null) {
            $this->worker_os_names[$current_machine] = $matches[1];
        } elseif (preg_match("/Docker Version: (.+)/", $line, $matches) === 1  && $current_machine !== null) {
            $this->worker_docker_versions[$current_machine] = $matches[1];
        } elseif (preg_match("/Tag: (.+)/", $line, $matches) === 1) {
            $this->parseImageDetails($matches[1]);
        } elseif (preg_match("/APIError was raised./", $line) === 1) {
            $this->error_logs[] = "APIError has occurred, please update the machines.";
        }

        return $current_machine;
    }

    /** Search for a worker by name and set its status to 'failed to update' */
    private function setWorkerToFailure(string $target_name) {
        foreach($this->worker_machines as &$worker) {
            if($worker->name == $target_name) {
                $worker->failed_to_update = true;
                break;
            }
        }
    }

    /** helper function to parse image information */
    private function parseImageDetails(string $tags): void {
        $image_array = explode(", ", $tags);    
        // Read next three lines for additional details
        $image = $this->readImageDetails();

        //take the first name in the list of name:tags and use that as the primary
        $image->primary_name = array_shift($image_array);
        $image->aliases = $image_array;
        if(array_key_exists($image->primary_name, $this->image_to_capability_mapping)) {
            $image->capabilities = $this->image_to_capability_mapping[$image->primary_name];
        }

        $this->docker_images[] = $image;
    }

    /** Collect the details of an image and return them in a map, in the future a class should represent the return */
    private function readImageDetails(): DockerImage {
        $log_lines = [];
        
        for ($i = 0; $i < 3; $i++) {
            $line = strtok("\n");
            if ($line === false) {
                throw new DockerLogParseException("Unexpected end of log while reading image details.");
            }

            $log_lines[] = $line;
        }

        return DockerImage::fromLog($log_lines);
    }

    /** Parse the logs under the sysinfo dir for worker machine info */
    private function parseSystemInformationLogs(): void {
        $sysinfo_files = scandir($this->sysinfo_filepath);
        if($sysinfo_files === false) {
           throw new DockerLogParseException("Failed to scandir at path '" . $this->sysinfo_filepath . "'" ); 
        }

        //ignore the '.' and '..' directories, if there are no files to parse, nothing to do, exit
        if(count($sysinfo_files) <= 2) {
            return;
        }

        $sysinfo_most_recent = max($sysinfo_files);
        $sysinfo_content = file_get_contents(FileUtils::joinPaths($this->sysinfo_filepath, $sysinfo_most_recent));

        if ($sysinfo_content === false || strlen($sysinfo_content) <= 45) {
            //the system info log file is probably being written or is in the process of being written, exit now 
            //and the next time the user loads the page it will be attempted to be read again
            return; 
        }

        //each subsequent update on the same day will append to the same docker log, navigate to the last update block and parse that
        $sysinfo_content = rtrim($sysinfo_content);
        $contentStart = strrpos($sysinfo_content, "[Last ran", -45);
        $contentStart = $contentStart === false ? 0 : $contentStart;
        $sysinfo_content = substr($sysinfo_content, $contentStart + 10);        
        $buffer = strtok($sysinfo_content, "\n");
        //the first line is expected to be "---", consume that to get to the start of the block
        $buffer = strtok("\n");
        $current_machine = null;

        $machine_system_details = [];
        while ($buffer !== false) {
            $matches = [];

            $is_match = preg_match("/System Info :: (.+)/", $buffer, $matches);
            if (preg_match("/System Info :: (.+)/", $buffer, $matches) === 1) {
                $current_machine = $matches[1];
            }

            if($current_machine === null) {
                //if have not set the current_machine at this point, keep consuming lines until we see it
                $buffer = strtok("\n");
                continue;
            }

            $is_match = preg_match("/Worker Service: (.+)/", $buffer, $matches);
            if ($is_match === 1 && $matches[1] != "Service Not Found") {
                $machine_system_details[$current_machine]["worker"] = $matches[1];
            }

            $is_match = preg_match("/Shipper Service: (.+)/", $buffer, $matches);
            if ($is_match === 1 && $matches[1] != "Service Not Found") {
                $machine_system_details[$current_machine]["shipper"] = $matches[1];
            }

            $is_match = preg_match("/Daemon Job Handler: (.+)/", $buffer, $matches);
            if ($is_match === 1 && $matches[1] != "Service Not Found") {
                $machine_system_details[$current_machine]["daemon"] = $matches[1];
            }

            $is_match = preg_match("/Disk Usage: (.+)/", $buffer, $matches);
            if ($is_match === 1) {
                $machine_system_details[$current_machine]["disk"] = $matches[1];
            }

            $is_match = preg_match("/System Load: \((.+)\)/", $buffer, $matches);
            if ($is_match === 1) {
                $machine_system_details[$current_machine]["load"] = $matches[1];
            }

            if (preg_match("/^\[Last ran on: (.+)\]/", $buffer, $matches) === 1) {
                $this->sysinfo_last_updated = $matches[1];
            }

            if (preg_match("/ERR:/", $buffer, $matches) === 1) {
                $error_logs[] = "Failed to update system info";
            }

            if (preg_last_error() != PREG_NO_ERROR) {
                $this->error_logs[] = "Error while parsing system info logs";
                break;
            }

            $buffer = strtok("\n");
        }

        foreach($machine_system_details as $key => $value) {
            $worker_info = WorkerMachineSystemInformation::fromArray($value, $key);
            //now find the worker and append the information parsed to it
            foreach($this->worker_machines as &$worker) {
                if($worker->name == $key) {
                    $worker->system_information = $worker_info;
                    $worker->docker_version = $this->worker_docker_versions[$key] ?? "Unknown";
                    $worker->os = $this->worker_os_names[$key] ?? "Unknown";
                    break;
                }
            }
        }
        
    }

}
