<?php

namespace app\models;

use app\libraries\Core;
use app\libraries\Utils;
use app\libraries\FileUtils;

use ParseError;

/** 
 * Simple class to represent docker image from parsed information
 */
class DockerImage {
    public string $id;
    public \DateTime $created;
    public string $size;

    public function __construct(string $id, \DateTime $created, string $size) {
        $this->id = $id;
        $this->created = $created;
        $this->size = $size;
    }

    /** 
     * Construct a new DockerImage from log lines
     * @throws ParseError
     */
    public static function fromLog(array $logLines): self {
        if (count($logLines) < 3) {
            throw new ParseError("Unexpected log input, insufficient lines for image details.");
        }

        // Parse ID
        if (!preg_match("/\t-id: (.+)/", $logLines[0], $matches)) {
            throw new ParseError("Unexpected log input, attempted to read image ID.");
        }

        $id = $matches[1];
        // Parse created date
        if (!preg_match("/\t-created: (.+)/", $logLines[1], $matches)) {
            throw new ParseError("Unexpected log input, attempted to read image creation date.");
        }

        $created = \DateTime::createFromFormat('Y-m-d\TH:i:s+', $matches[1]);
        if (!$created) {
            throw new ParseError("Invalid date format in log input.");
        }

        // Parse size
        if (!preg_match("/\t-size: (.+)/", $logLines[2], $matches)) {
            throw new ParseError("Unexpected log input, attempted to read image size.");
        }

        $size = Utils::formatBytes('mb', $matches[1], true);
        return new self($id, $created, $size);
    }
}

/**
 * Represents the data parsed from the docker autograding and worker json files
 * 
 * @method string getWorkerMachineNames()
 * @method string getCapabilities()
 * @method string getNoImageCapabilities()
 * @method string getWorkerMachineNames()
 * @method string getImageToCapabilityMapping()
 * @method string getCapabilityToColorMapping()
 * @method string getLastRan()
 * @method array getErrorLogs()
 */
class DockerUI extends AbstractModel {
    /** Json data passed in */
    private array $json_data;
    /** List of worker machine names */
    protected array $worker_machine_names;
    /** List of capability tags */
    protected array $capabilities;
    /** List of capabilities unassociated with any container */
    protected array $no_image_capabilities;
    /** Mapping between images to capabilities */
    protected array $image_to_capability_mapping;
    /** Mapping between capabilities and the color to draw their badge */
    protected array $capability_to_color_mapping;
    /** Human readable string of when the docker and sysinfo logs were last parsed */
    protected string $last_ran = "Unknown";
    /** List of errors from parsing log files  */
    protected array $error_logs = [];
    /** location of where the sysinfo log files generated by Submitty are located */
    private string $sysinfo_filepath;
    /** location of where logs generated by Submitty related to docker are located */
    private string $docker_logpath;
    /** Create a new docker UI object from the json data read from the filesystem */
    public function __construct(Core $core, array $json) {
        parent::__construct($core);

        /** Sanity checks on given json structure */
        assert(array_key_exists('autograding_workers', $json) && is_array($json['autograding_workers']));
        assert(array_key_exists('autograding_containers', $json) && is_array($json['autograding_containers']));

        $this->sysinfo_filepath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "sysinfo");
        $this->docker_logpath = FileUtils::joinPaths($this->core->getConfig()->getSubmittyPath(), "logs", "docker");

        $this->json_data = $json;
        $this->parseWorkersAndCapabilities($this->json_data['autograding_containers'], $this->json_data['autograding_workers']);
        $this->parseDockerLogs();
    }

    /** Return a list of autograding worker names */
    public function getAutogradingContainers(): array {
        return $this->json_data['autograding_containers'];
    }

    /** Collect which capabilities are present along with the workers associated with and any that are unaassociated */
    private function parseWorkersAndCapabilities(array $autograding_containers, array $autograding_workers): void {
        $capabilities = [];
        $no_image_capabilities = [];
        $image_to_capability = [];
        
        foreach ($autograding_workers as $name => $worker) {
            //worker with some defaults
            $worker_temp = [
                'name' => $name,
                'num_autograding_workers' => $worker['num_autograding_workers'] ?? 0,
                'enabled' => $worker['enabled'] ?? false,
                'capabilities' => $worker['capabilities'] ?? [],
                'images_not_found' => [],
            ];

            foreach ($worker_temp['capabilities'] as $capability) {
                $capabilities[] = $capability;
    
                if (isset($autograding_containers[$capability])) {
                    foreach ($autograding_containers[$capability] as $image) {
                        $image_to_capability[$image][] = $capability;
                    }
                } else {
                    $no_image_capabilities[] = $capability;
                    $workerTemp['images_not_found'][] = $capability;
                }
            }

            $this->worker_machine_names[] = $worker_temp;
        }

        sort($capabilities);
        $this->capabilities = array_unique($capabilities);
        //deduplicate capability lists
        $this->no_image_capabilities = array_unique($no_image_capabilities);
        $this->image_to_capability_mapping = array_map('array_unique', $image_to_capability);

        foreach ($image_to_capability as $image => $map) {
            $image_to_capability[$image] = array_unique($map);
        }

        $this->image_to_capability_mapping = $image_to_capability;
        $this->capability_to_color_mapping = [];
        foreach ($this->capabilities as $index => $capability) {
            $this->capability_to_color_mapping[$capability] = min($index + 1, 20);
        }
    }

    /** 
     * Entry point to parse logs generated by Submitty containing information on docker images across workers
     * @throws ParseError
     */
    private function parseDockerLogs(): void {
        $array_list = scandir($this->docker_logpath);
        if($array_list === false) {
           throw new ParseError("Failed to scandir at path '" . $this->docker_logpath . "'" ); 
        }

        //ignore the '.' and '..' directories, if there are no files to parse, nothing to do, exit
        if(count($array_list) <= 2) {
            return;
        }

        $most_recent = max($array_list);
        $content = file_get_contents(FileUtils::joinPaths($this->docker_logpath, $most_recent));
        if($content === false) {
            //the docker log file is probably being written or is in the process of being written, exit now 
            //and the next time the user loads the page it will be attempted to be read again
            return; 
        }

        $content = rtrim($content);
        $contentStart = strrpos($content, "[Last ran", -35);
        $contentStart = $contentStart === false ? 0 : $contentStart + 10;
        $content = substr($content, $contentStart);

        $buffer = strtok($content, "\n");
        $current_machine = "";

        while ($buffer !== false) {
            $this->parseLogLine($buffer, $currentMachine);
            if (preg_last_error() != PREG_NO_ERROR) {
                $error_logs[] = "Error while parsing the logs";
                break;
            }
            $buffer = strtok("\n");
        }
        
    }

    /** Helper function to parse docker logs, updates currentMachine if applicable */
    private function parseLogLine(string $line, string &$currentMachine): void {
        $matches = [];
    
        // Match patterns
        if (preg_match("/^\[Last ran on: ([0-9 :-]{19})\]/", $line, $matches) === true) {
            $this->lastRan = $matches[1];
        } elseif (preg_match("/FAILURE TO UPDATE MACHINE (.+)$/", $line, $matches) === true) {
            $this->machineToUpdate[$matches[1]] = false;
            $this->errorLogs[] = $line;
        } elseif (preg_match("/ERROR: Could not pull (.+)/", $line, $matches) === true) {
            $this->failImages = $matches[1];
            $this->errorLogs[] = $line;
        } elseif (preg_match("/UPDATE MACHINE: (.+)/", $line, $matches) === true) {
            $currentMachine = $matches[1];
        } elseif (preg_match("/Description:\t(.+)/", $line, $matches) === true) {
            $this->machineSystemDetails[$currentMachine]['os'] = $matches[1] ?? null;
        } elseif (preg_match("/Docker Version: (.+)/", $line, $matches) === true) {
            $this->machineDockerVersion[$currentMachine] = $matches[1];
        } elseif (preg_match("/Tag: (.+)/", $line, $matches) === true) {
            $this->parseImageDetails($line, $matches[1]);
        } elseif (preg_match("/APIError was raised./", $line) === true) {
            $this->errorLogs[] = "APIError has occurred, please update the machines.";
        }
    }

    /** helper function to parse image information */
    private function parseImageDetails(string $line, string $tags): void {
        $imageArr = explode(", ", $tags);
        $currentImage = array_shift($imageArr);
    
        $this->aliases[$currentImage] = array_merge([$currentImage], $imageArr);
        foreach ($imageArr as $image) {
            $this->aliases[$image][] = $currentImage;
        }
    
        // Read next three lines for additional details
        $image = $this->readImageDetails();
        foreach ($this->aliases[$currentImage] as $alias) {
            $this->imageInfo[$alias] = $image;
        }
    }

    /** Collect the details of an image and return them in a map, in the future a class should represent the return */
    private function readImageDetails(): DockerImage {
        $logLines = [];
        for ($i = 0; $i < 3; $i++) {
            $line = strtok("\n");
            if ($line === false) {
                throw new ParseError("Unexpected end of log while reading image details.");
            }
            $logLines[] = $line;
        }

        return DockerImage::fromLog($logLines);
    }

    private function parseSystemInformationLogs(): void {
        if (count($sysinfo_files) > 2) {
            $sysinfo_most_recent = max($sysinfo_files);
            $sysinfo_content = file_get_contents(
                FileUtils::joinPaths(
                    $this->core->getConfig()->getSubmittyPath(),
                    "logs/sysinfo",
                    $sysinfo_most_recent
                )
            );

            if ($sysinfo_content) {
                $sysinfo_content = rtrim($sysinfo_content);
                $sysinfo_2rpos = strrpos($sysinfo_content, "[Last ran", -45);
                if ($sysinfo_2rpos === false) {
                    $sysinfo_2rpos = 0;
                }
                $sysinfo_content = substr($sysinfo_content, $sysinfo_2rpos + 10);
                $buffer = strtok($sysinfo_content, "\n");
                $current_machine = "";

                while ($buffer !== false) {
                    $matches = [];

                    $is_match = preg_match("/System Info :: (.+)/", $buffer, $matches);
                    if ($is_match) {
                        $current_machine = $matches[1];
                        $machine_system_details[$current_machine]["worker"] = null;
                        $machine_system_details[$current_machine]["shipper"] = null;
                        $machine_system_details[$current_machine]["daemon"] = null;
                        $machine_system_details[$current_machine]["disk"] = null;
                        $machine_system_details[$current_machine]["load"] = null;
                        $machine_system_details[$current_machine]["os"] ??= null;
                    }

                    $is_match = preg_match("/Worker Service: (.+)/", $buffer, $matches);
                    if ($is_match && $matches[1] != "Service Not Found") {
                        $machine_system_details[$current_machine]["worker"] = $matches[1];
                    }

                    $is_match = preg_match("/Shipper Service: (.+)/", $buffer, $matches);
                    if ($is_match && $matches[1] != "Service Not Found") {
                        $machine_system_details[$current_machine]["shipper"] = $matches[1];
                    }

                    $is_match = preg_match("/Daemon Job Handler: (.+)/", $buffer, $matches);
                    if ($is_match && $matches[1] != "Service Not Found") {
                        $machine_system_details[$current_machine]["daemon"] = $matches[1];
                    }

                    $is_match = preg_match("/Disk Usage: (.+)/", $buffer, $matches);
                    if ($is_match) {
                        $machine_system_details[$current_machine]["disk"] = $matches[1];
                    }

                    $is_match = preg_match("/System Load: \((.+)\)/", $buffer, $matches);
                    if ($is_match) {
                        $machine_system_details[$current_machine]["load"] = $matches[1];
                    }

                    $is_match = preg_match("/^\[Last ran on: (.+)\]/", $buffer, $matches);
                    if ($is_match) {
                        $sysinfo_last_updated = $matches[1];
                    }

                    $is_match = preg_match("/ERR:/", $buffer, $matches);
                    if ($is_match) {
                        $error_logs[] = "Failed to update system info";
                    }

                    if (preg_last_error() != PREG_NO_ERROR) {
                        $error_logs[] = "Error while parsing system info logs";
                        break;
                    }

                    $buffer = strtok("\n");
                }
            }
        }
    }

}